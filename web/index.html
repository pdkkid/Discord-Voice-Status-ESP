<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Discord Voice Status ESP Installer</title>
    <style>
      :root {
        --primary: #5865F2;
        --primary-dark: #4752C4;
        --bg: #36393f;
        --bg-secondary: #2f3136;
        --text: #dcddde;
        --text-muted: #72767d;
        --success: #43b581;
        --error: #f04747;
      }
      * { box-sizing: border-box; }
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: var(--bg);
        color: var(--text);
        margin: 0;
        padding: 20px;
        min-height: 100vh;
      }
      .container {
        max-width: 600px;
        margin: 0 auto;
      }
      h1 {
        color: #fff;
        margin-bottom: 8px;
      }
      .subtitle {
        color: var(--text-muted);
        margin-bottom: 24px;
      }
      .card {
        background: var(--bg-secondary);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 16px;
      }
      .card h2 {
        margin-top: 0;
        font-size: 1.1em;
        color: #fff;
      }
      .step-number {
        display: inline-block;
        width: 28px;
        height: 28px;
        background: var(--primary);
        border-radius: 50%;
        text-align: center;
        line-height: 28px;
        margin-right: 10px;
        font-weight: bold;
      }
      label {
        display: block;
        margin-bottom: 6px;
        color: var(--text-muted);
        font-size: 0.9em;
        text-transform: uppercase;
        font-weight: 600;
      }
      input[type="text"], input[type="password"], input[type="url"] {
        width: 100%;
        padding: 10px 12px;
        border: none;
        border-radius: 4px;
        background: var(--bg);
        color: var(--text);
        font-size: 1em;
        margin-bottom: 12px;
      }
      input:focus {
        outline: 2px solid var(--primary);
      }
      button {
        background: var(--primary);
        color: #fff;
        border: none;
        padding: 12px 24px;
        border-radius: 4px;
        font-size: 1em;
        cursor: pointer;
        transition: background 0.2s;
      }
      button:hover {
        background: var(--primary-dark);
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .btn-secondary {
        background: var(--bg);
      }
      .btn-secondary:hover {
        background: #40444b;
      }
      .status {
        padding: 10px;
        border-radius: 4px;
        margin-top: 12px;
        display: none;
      }
      .status.success {
        display: block;
        background: rgba(67, 181, 129, 0.2);
        color: var(--success);
      }
      .status.error {
        display: block;
        background: rgba(240, 71, 71, 0.2);
        color: var(--error);
      }
      .status.info {
        display: block;
        background: rgba(88, 101, 242, 0.2);
        color: var(--primary);
      }
      esp-web-install-button {
        display: block;
        margin: 16px 0;
      }
      .hidden { display: none !important; }
      .flex-row {
        display: flex;
        gap: 10px;
      }
      .flex-row button {
        flex: 1;
      }
      #serial-log {
        background: #1e1e1e;
        padding: 10px;
        border-radius: 4px;
        font-family: monospace;
        font-size: 0.85em;
        max-height: 150px;
        overflow-y: auto;
        margin-top: 12px;
        white-space: pre-wrap;
        word-break: break-all;
      }
      .note {
        font-size: 0.85em;
        color: var(--text-muted);
        margin-top: 8px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üéÆ Discord Voice Status ESP</h1>
      <p class="subtitle">Flash and configure your ESP device for Discord voice status indication</p>

      <!-- Step 1: Flash -->
      <div class="card">
        <h2><span class="step-number">1</span>Flash Firmware</h2>
        
        <!-- ESP8266 / Standard ESP32 -->
        <div style="margin-bottom: 16px; padding: 12px; background: var(--bg); border-radius: 4px;">
          <p style="margin: 0 0 8px 0;"><strong>ESP8266 / ESP32 (with USB-UART chip):</strong></p>
          <script type="module" src="https://unpkg.com/esp-web-tools@10/dist/web/install-button.js?module"></script>
          <esp-web-install-button id="installBtn" manifest="./manifest.json"></esp-web-install-button>
        </div>
        
        <!-- ESP32-S2 Native USB -->
        <div style="margin-bottom: 16px; padding: 12px; background: var(--bg); border-radius: 4px; border: 1px solid var(--warning);">
          <p style="margin: 0 0 8px 0;"><strong style="color: var(--warning);">ESP32-S2 (Native USB - e.g., LOLIN S2 Mini):</strong></p>
          <ol style="margin: 0 0 12px 0; padding-left: 20px; font-size: 0.9em; color: var(--text-muted);">
            <li>Unplug the device</li>
            <li>Hold the <strong>0 (BOOT)</strong> button</li>
            <li>Plug in USB while holding</li>
            <li>Release after 1 second</li>
            <li>Click the button below</li>
          </ol>
          <button id="flashS2Btn" onclick="flashESP32S2()">‚ö° Flash ESP32-S2</button>
          <div id="s2Progress" style="margin-top: 8px; display: none;">
            <div style="background: var(--card); border-radius: 4px; overflow: hidden; height: 20px;">
              <div id="s2ProgressBar" style="background: var(--primary); height: 100%; width: 0%; transition: width 0.3s;"></div>
            </div>
            <span id="s2ProgressText" class="note"></span>
          </div>
        </div>
        
        <div style="margin-top: 12px;">
          <button id="eraseBtn" class="btn-secondary" onclick="eraseDevice()" style="background: var(--error);">üóëÔ∏è Erase Flash</button>
          <span class="note" style="margin-left: 8px;">Completely wipes the device</span>
        </div>
        
        <p class="note">After flashing, press RST button, then click "Connect Serial" to configure.</p>
      </div>

      <!-- Step 2: Configure -->
      <div class="card">
        <h2><span class="step-number">2</span>Configure Device</h2>
        <p>Enter your settings and send to device via serial.</p>
        
        <label for="wsUrl">WebSocket URL</label>
        <input type="url" id="wsUrl" placeholder="wss://your-server.com/ws" />
        
        <label for="authToken">Auth Token</label>
        <input type="password" id="authToken" placeholder="Your authentication token" />
        
        <label for="wifiSsid">WiFi Network Name (SSID) <span style="color: var(--text-muted); font-weight: normal;">(optional)</span></label>
        <input type="text" id="wifiSsid" placeholder="Your WiFi network name" autocomplete="off" />
        
        <label for="wifiPass">WiFi Password <span style="color: var(--text-muted); font-weight: normal;">(optional)</span></label>
        <input type="password" id="wifiPass" placeholder="Your WiFi password" />
        
        <div class="flex-row">
          <button id="connectBtn" onclick="connectSerial()">Connect Serial</button>
          <button id="disconnectBtn" class="btn-secondary" onclick="disconnectSerial()" disabled>Disconnect</button>
          <button id="sendConfigBtn" onclick="sendConfig()" disabled>Send Config</button>
        </div>
        
        <div class="flex-row" style="margin-top: 10px;">
          <button id="getConfigBtn" class="btn-secondary" onclick="getConfig()" disabled>Read Config</button>
          <button id="rebootBtn" class="btn-secondary" onclick="rebootDevice()" disabled>Reboot</button>
        </div>
        
        <div id="status" class="status"></div>
        <div id="serial-log" class="hidden"></div>
      </div>

      <!-- Step 3: WiFi -->
      <div class="card">
        <h2><span class="step-number">3</span>Alternative: Captive Portal</h2>
        <p>If you prefer, skip WiFi config above and connect to the <strong>DiscordVoiceSetup</strong> WiFi network after the device boots to configure via captive portal (also supports 802.1X Enterprise).</p>
      </div>
    </div>

    <script>
      let port = null;
      let reader = null;
      let writer = null;
      let readBuffer = '';
      let isReading = false;

      function setStatus(message, type = 'info') {
        const el = document.getElementById('status');
        el.textContent = message;
        el.className = 'status ' + type;
      }

      function log(text) {
        const el = document.getElementById('serial-log');
        el.classList.remove('hidden');
        el.textContent += text + '\n';
        el.scrollTop = el.scrollHeight;
      }
      
      async function eraseDevice() {
        if (!confirm('‚ö†Ô∏è This will completely erase the device flash!\n\nFor ESP32-S2: Make sure you entered bootloader mode first.\n\nContinue?')) {
          return;
        }
        
        // Disconnect any existing serial connection first
        if (port) {
          try {
            await disconnectSerial();
          } catch (e) {
            console.log('Disconnect before erase:', e);
          }
        }
        
        const eraseBtn = document.getElementById('eraseBtn');
        eraseBtn.disabled = true;
        eraseBtn.textContent = '‚è≥ Erasing...';
        setStatus('Connecting to device...', 'info');
        
        let erasePort = null;
        let transport = null;
        
        try {
          // Import ESPLoader dynamically
          const { ESPLoader, Transport } = await import('https://unpkg.com/esptool-js@0.4.3/bundle.js');
          
          // Request serial port
          erasePort = await navigator.serial.requestPort();
          await erasePort.open({ baudRate: 115200 });
          
          transport = new Transport(erasePort, true);
          const esploader = new ESPLoader({
            transport,
            baudrate: 115200,
            romBaudrate: 115200,
            terminal: {
              clean() {},
              writeLine(data) { log(data); },
              write(data) { log(data); }
            }
          });
          
          setStatus('Connecting to bootloader...', 'info');
          await esploader.main();
          
          setStatus('Erasing flash... (this may take a minute)', 'info');
          await esploader.eraseFlash();
          
          setStatus('‚úÖ Flash erased successfully! Device is now blank.', 'success');
        } catch (err) {
          console.error('Erase error:', err);
          setStatus('‚ùå Erase failed: ' + err.message, 'error');
        } finally {
          // Clean up
          try {
            if (transport) await transport.disconnect();
          } catch (e) {}
          try {
            if (erasePort) await erasePort.close();
          } catch (e) {}
          eraseBtn.disabled = false;
          eraseBtn.textContent = 'üóëÔ∏è Erase Flash';
        }
      }
      
      async function flashESP32S2() {
        // Disconnect any existing serial connection first
        if (port) {
          try { await disconnectSerial(); } catch (e) {}
        }
        
        const flashBtn = document.getElementById('flashS2Btn');
        const progressDiv = document.getElementById('s2Progress');
        const progressBar = document.getElementById('s2ProgressBar');
        const progressText = document.getElementById('s2ProgressText');
        
        flashBtn.disabled = true;
        flashBtn.textContent = '‚è≥ Connecting...';
        progressDiv.style.display = 'block';
        progressBar.style.width = '0%';
        progressText.textContent = 'Requesting port...';
        
        let flashPort = null;
        let transport = null;
        
        try {
          // Import ESPLoader
          const { ESPLoader, Transport } = await import('https://unpkg.com/esptool-js@0.4.3/bundle.js');
          
          // Request serial port
          flashPort = await navigator.serial.requestPort();
          await flashPort.open({ baudRate: 115200 });
          
          transport = new Transport(flashPort, true);
          
          progressText.textContent = 'Connecting to bootloader...';
          progressBar.style.width = '5%';
          
          const esploader = new ESPLoader({
            transport,
            baudrate: 115200,
            romBaudrate: 115200,
            terminal: {
              clean() {},
              writeLine(data) { log(data); },
              write(data) { log(data); }
            }
          });
          
          const chip = await esploader.main();
          log('Detected chip: ' + chip);
          progressText.textContent = 'Detected: ' + chip;
          progressBar.style.width = '10%';
          
          if (!chip.toLowerCase().includes('esp32-s2') && !chip.toLowerCase().includes('esp32s2')) {
            throw new Error('This button is for ESP32-S2 only. Detected: ' + chip);
          }
          
          // Fetch the firmware
          progressText.textContent = 'Downloading firmware...';
          progressBar.style.width = '15%';
          
          const manifestResp = await fetch('./manifest.json');
          const manifest = await manifestResp.json();
          
          // Find ESP32-S2 build
          const s2Build = manifest.builds.find(b => 
            b.chipFamily === 'ESP32-S2' || 
            (b.parts && b.parts.some(p => p.path.includes('esp32s2')))
          );
          
          if (!s2Build) {
            throw new Error('No ESP32-S2 firmware found in manifest');
          }
          
          // Download all parts
          const fileArray = [];
          for (const part of s2Build.parts) {
            progressText.textContent = 'Downloading: ' + part.path;
            const resp = await fetch(part.path);
            const data = await resp.arrayBuffer();
            fileArray.push({ data: new Uint8Array(data), address: part.offset });
            log('Downloaded: ' + part.path + ' (' + data.byteLength + ' bytes @ 0x' + part.offset.toString(16) + ')');
          }
          
          progressText.textContent = 'Flashing firmware...';
          progressBar.style.width = '20%';
          
          // Flash with progress
          const flashOptions = {
            fileArray,
            flashSize: 'keep',
            flashMode: 'keep',
            flashFreq: 'keep',
            eraseAll: false,
            compress: true,
            reportProgress: (fileIndex, written, total) => {
              const pct = 20 + Math.round((written / total) * 75);
              progressBar.style.width = pct + '%';
              progressText.textContent = 'Writing: ' + Math.round((written / total) * 100) + '%';
            }
          };
          
          await esploader.writeFlash(flashOptions);
          
          progressBar.style.width = '100%';
          progressText.textContent = '‚úÖ Flash complete! Press RST button to boot.';
          setStatus('‚úÖ ESP32-S2 flashed successfully! Press the RST button.', 'success');
          
        } catch (err) {
          console.error('Flash error:', err);
          progressText.textContent = '‚ùå ' + err.message;
          setStatus('‚ùå Flash failed: ' + err.message, 'error');
        } finally {
          try { if (transport) await transport.disconnect(); } catch (e) {}
          try { if (flashPort) await flashPort.close(); } catch (e) {}
          flashBtn.disabled = false;
          flashBtn.textContent = '‚ö° Flash ESP32-S2';
        }
      }

      function updateButtons(connected) {
        document.getElementById('connectBtn').textContent = connected ? 'Connected ‚úì' : 'Connect Serial';
        document.getElementById('connectBtn').disabled = connected;
        document.getElementById('disconnectBtn').disabled = !connected;
        document.getElementById('sendConfigBtn').disabled = !connected;
        document.getElementById('getConfigBtn').disabled = !connected;
        document.getElementById('rebootBtn').disabled = !connected;
      }

      async function connectSerial() {
        try {
          port = await navigator.serial.requestPort();
          await port.open({ baudRate: 115200 });
          
          writer = port.writable.getWriter();
          reader = port.readable.getReader();
          isReading = true;
          
          updateButtons(true);
          setStatus('Connected! Entering config mode...', 'info');
          
          // Start reading
          readLoop();
          
          // Send WEB_CONFIG to enter extended configuration mode
          await sendCommand('WEB_CONFIG');
        } catch (err) {
          setStatus('Failed to connect: ' + err.message, 'error');
        }
      }

      async function disconnectSerial() {
        try {
          isReading = false;
          
          if (reader) {
            await reader.cancel();
            reader.releaseLock();
            reader = null;
          }
          if (writer) {
            writer.releaseLock();
            writer = null;
          }
          if (port) {
            await port.close();
            port = null;
          }
          
          updateButtons(false);
          setStatus('Disconnected', 'info');
        } catch (err) {
          console.error('Disconnect error:', err);
          // Reset state anyway
          reader = null;
          writer = null;
          port = null;
          updateButtons(false);
          setStatus('Disconnected', 'info');
        }
      }

      async function readLoop() {
        try {
          while (isReading) {
            const { value, done } = await reader.read();
            if (done || !isReading) break;
            
            const text = new TextDecoder().decode(value);
            readBuffer += text;
            
            // Process complete lines
            let lines = readBuffer.split('\n');
            readBuffer = lines.pop(); // Keep incomplete line in buffer
            
            for (const line of lines) {
              const trimmed = line.trim();
              if (trimmed) {
                log('‚Üê ' + trimmed);
                handleResponse(trimmed);
              }
            }
          }
        } catch (err) {
          if (err.name !== 'NetworkError' && isReading) {
            console.error('Read error:', err);
          }
        }
      }

      function handleResponse(line) {
        if (line === 'OK:CONFIG_SAVED') {
          setStatus('Configuration saved! Device will reboot...', 'success');
        } else if (line === 'OK:REBOOTING') {
          setStatus('Device is rebooting...', 'info');
        } else if (line === 'OK:WEB_CONFIG_MODE') {
          setStatus('‚úì Config mode active! Enter your settings and click Send Config.', 'success');
        } else if (line.startsWith('CONFIG:')) {
          try {
            const config = JSON.parse(line.substring(7));
            document.getElementById('wifiSsid').value = config.wifiSsid || '';
            document.getElementById('wsUrl').value = config.wsUrl || '';
            setStatus('Config loaded. Version: ' + config.version, 'success');
          } catch (e) {
            console.error('Failed to parse config:', e);
          }
        } else if (line.startsWith('ERR:')) {
          setStatus('Error: ' + line.substring(4), 'error');
        } else if (line === '‚úÖ Configuration complete!') {
          setStatus('Configuration complete! Connect to DiscordVoiceSetup WiFi to finish.', 'success');
        }
      }

      async function sendCommand(cmd) {
        if (!writer) {
          setStatus('Not connected', 'error');
          return;
        }
        log('‚Üí ' + cmd);
        await writer.write(new TextEncoder().encode(cmd + '\n'));
      }

      async function sendConfig() {
        const wifiSsid = document.getElementById('wifiSsid').value.trim();
        const wifiPass = document.getElementById('wifiPass').value.trim();
        const wsUrl = document.getElementById('wsUrl').value.trim();
        const authToken = document.getElementById('authToken').value.trim();
        
        if (!wsUrl) {
          setStatus('Please enter a WebSocket URL', 'error');
          return;
        }
        
        const config = { wsUrl };
        if (authToken) config.authToken = authToken;
        if (wifiSsid) config.wifiSsid = wifiSsid;
        if (wifiPass) config.wifiPass = wifiPass;
        
        await sendCommand('CONFIG:' + JSON.stringify(config));
        setStatus('Sending configuration...', 'info');
      }

      async function getConfig() {
        await sendCommand('GET_CONFIG');
        setStatus('Reading configuration...', 'info');
      }

      async function rebootDevice() {
        await sendCommand('REBOOT');
      }

      // Check for Web Serial support
      if (!('serial' in navigator)) {
        document.getElementById('status').textContent = 
          'Web Serial is not supported in this browser. Use Chrome or Edge.';
        document.getElementById('status').className = 'status error';
        document.getElementById('connectBtn').disabled = true;
      }

      // Listen for ESP Web Tools install complete event
      document.addEventListener('DOMContentLoaded', () => {
        const installBtn = document.getElementById('installBtn');
        if (installBtn) {
          installBtn.addEventListener('state-changed', (e) => {
            if (e.detail.state === 'finished') {
              setStatus('‚úÖ Flash complete! Click "Connect Serial" now to configure.', 'success');
              // Highlight the connect button
              document.getElementById('connectBtn').style.animation = 'pulse 1s infinite';
            }
          });
        }
      });
    </script>
    <style>
      @keyframes pulse {
        0%, 100% { box-shadow: 0 0 0 0 rgba(88, 101, 242, 0.7); }
        50% { box-shadow: 0 0 0 10px rgba(88, 101, 242, 0); }
      }
    </style>
  </body>
</html>
